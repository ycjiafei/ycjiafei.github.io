{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://ycjiafei.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-12-08T08:31:46.884Z","updated":"2020-12-08T07:31:51.040Z","comments":false,"path":"/404.html","permalink":"http://ycjiafei.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2020-12-08T08:31:46.900Z","updated":"2020-12-08T07:31:51.040Z","comments":false,"path":"categories/index.html","permalink":"http://ycjiafei.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-12-08T08:31:46.898Z","updated":"2020-12-08T07:31:51.038Z","comments":false,"path":"books/index.html","permalink":"http://ycjiafei.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-12-08T08:31:46.903Z","updated":"2020-12-08T07:31:51.039Z","comments":true,"path":"links/index.html","permalink":"http://ycjiafei.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-12-08T08:32:05.990Z","updated":"2020-12-08T07:31:51.038Z","comments":false,"path":"about/index.html","permalink":"http://ycjiafei.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2020-12-08T08:31:46.907Z","updated":"2020-12-08T07:31:51.039Z","comments":false,"path":"tags/index.html","permalink":"http://ycjiafei.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-12-08T08:31:46.905Z","updated":"2020-12-08T07:31:51.038Z","comments":false,"path":"repository/index.html","permalink":"http://ycjiafei.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Lua 影响 Redis 吞吐量排查","slug":"Lua 影响 Redis 吞吐量问题","date":"2021-01-04T17:04:59.000Z","updated":"2021-01-04T09:23:58.387Z","comments":true,"path":"2021/01/04/Lua 影响 Redis 吞吐量问题/","link":"","permalink":"http://ycjiafei.github.io/2021/01/04/Lua%20%E5%BD%B1%E5%93%8D%20Redis%20%E5%90%9E%E5%90%90%E9%87%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"背景项目中日常使用 redis 用作频繁查库的缓存层，其中使用 lua 来增强 redis 的查询和插入功能， 类似mysql 的批量更新，尽量用一次 io 来搞定需要操作的数据， 上线之初运行良好， 大概过了半年时间， 其中有个别 频繁查询 redis 的 API 出现高延迟的现象， 出现时间不固定，大概可以锁定是 redis 的响应慢导致 API 查询时间过长。而导致 redis 响应慢的主要原因是上面提到的 Lua 脚本导致。 测试在单实例中， 新建一个 key ， 然后执行一个需要消耗长时间的lua脚本 1eval &quot;local a=redis.call(&#x27;hget&#x27;,&#x27;test1&#x27;,&#x27;name&#x27;) local b=1 repeat b=b+1 until(b&gt;100000000000000) return a&quot; 0 然后开启另一个终端， 执行查询操作 keys * 12local:0&gt;keys *&quot;BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.&quot; redis 提示 有脚本正在运行， 只能使用 SCRIPT KILL 或 SHUTDOWN NOSAVE 命令终止脚本运行。 总结lua 确实可以增强 redis 的操作，方便在代码中写循环语句操作 redis， 同时要注意在 单实例的 redis 中， 要评估 lua 脚本的开销， 最好是在 redis 集群中使用 redis， 则 lua 不影响 redis 的读写性能","categories":[{"name":"项目踩坑","slug":"项目踩坑","permalink":"http://ycjiafei.github.io/categories/%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"项目踩坑","slug":"项目踩坑","permalink":"http://ycjiafei.github.io/tags/%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/"},{"name":"Redis","slug":"Redis","permalink":"http://ycjiafei.github.io/tags/Redis/"}]},{"title":"二进制减法器","slug":"二进制减法器","date":"2020-12-08T20:18:34.000Z","updated":"2020-12-08T11:55:12.457Z","comments":true,"path":"2020/12/08/二进制减法器/","link":"","permalink":"http://ycjiafei.github.io/2020/12/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%87%8F%E6%B3%95%E5%99%A8/","excerpt":"","text":"在减法中没有进位，而是有借位——一种与加法存在本质区别的麻烦机制 不通过借位的减法既然借位很麻烦， 那么我们就可以寻找另一种减法方式 比如要计算 253- 176 第一步：减数求补因为是 十进制数， 所以要对 9 求补 823 第二步：补数与被减数相加823 + 253 = 1076 第三步：将结果 + 11076 + 1 = 1077 第四步：将结果减去 1000**1077 - 1000 = 77 ** 到此，我们就得到了结果。答案与先前的相同，而且没有用到借位。 然后用以下方式将数字重新组合： 253 + (999 - 176) + 1 - 1000 这个式子与下式等价： 253 - 176 + 999 + 1 - 1000 我们用两个减法和两个加法来替代一个减法，而在这个过程中避免了烦琐的借位。 应用到二进制数还是用上面的 253- 176 转换为二进制算法 第一步：减数求补由于我们是2进制数 ，就不能对 9 求补， 应该对 1 求补，但是请注意，我们在求对1的补数时并不需要用到减法。在求对1的补数时，只需将原来的二进制数中的1变为0，将0变为1即可。因此对1求补数有时也会称为相反数（negation）或反码（inverse） 第二步：补数与被减数相加 第三步：将结果 + 1 第四步：将结果减去 100000000这里减去的数是求补的最大数+ 1， 对于3位的十进制数来说就是 999 + 1 = 1000 对于4位二进制数来说就是 1111 + 1 = 10000， 8位二进制数以此类推 到这里，我们已经有了足够的条件来改造上一章所搭建的加法器，并让它像实现加法一样来实现减法运算。 搭建减法器8位加/减法器所用的新面板较从前做了些许的改动。它增设了一个开关，用以选择做加法还是做减法。 如上图所示，这个开关向下断开时表示选择加法运算，反之向上接通则表示选择减法运算。此外，右侧的8个灯泡用于表示计算结果。这里，第9个灯泡表示“上溢/下溢”。这个灯泡表明了正在计算的数字是一个不能用8个灯泡来表示的数字。如果在加法中得到了大于255（上溢，overflow）或在减法中得到了负数（下溢，underflow）这个灯泡就会发光。当减数大于被减数的时候，就会得到一个负数。 加法器中新增的主要部分就是一个用来求8位二进制数对1补数的电路。之前提到，二进制数对1求补数相当于对其每位取反，因此我们计算8位二进制数补数的时候可以简单地应用8个反向器 问题是，该电路只会对输入求反，而我们要的是一台既能做加法又能做减法的机器，因此就要求该电路当且仅当进行减法运算时才实现反转。电路可以改造为如下图所示。 将8个异或门合并起来画成一个器件，称为求补器（One’s Complement），如下所示 将一个求补器，一个8位二进制加法器和一个异或门做如下连接。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://ycjiafei.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"逻辑","slug":"逻辑","permalink":"http://ycjiafei.github.io/tags/%E9%80%BB%E8%BE%91/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://ycjiafei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"溢出和进位","slug":"溢出和进位","date":"2020-12-08T18:18:34.000Z","updated":"2020-12-08T11:17:24.192Z","comments":true,"path":"2020/12/08/溢出和进位/","link":"","permalink":"http://ycjiafei.github.io/2020/12/08/%E6%BA%A2%E5%87%BA%E5%92%8C%E8%BF%9B%E4%BD%8D/","excerpt":"","text":"溢出（overflow） 运算结果超出了正常表示 范围 仅针对有符号数运算 两个正数相加，结果为负数 两个负数相加，结果为正数 如何理解这两点？来看两个例子 可以看到，计算机在执行算数运算的时不关心有符号还是无符号，这是人类定义的（补码表示法），因为补码的存在，导致两个正数或两个负数相加时，改变了符号位，导致结果变得很离谱。 进位由于没有了最高位表示符号， 所以补码就不存在， 但是无符号数产生回绕。 如 11111111 为 255， 而 255 + 1 = 0， 因为发生了进位，255 + 2 = 1 结果开始从 0 ～ 255 循环 但是这种进位不能算溢出，因为计算机和传统代数不一样， 计算机是在有限域上的运算， 我们看到的 255 + 1 = 0 是合理的， 因为超出了域， 进位被舍弃了。 标志为了解决这种问题， 于是就有了 cpu 的标志位，当结果有溢出时， OF 位为 1， 最终结果发生了进位，则 CF 位为 1","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://ycjiafei.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"逻辑","slug":"逻辑","permalink":"http://ycjiafei.github.io/tags/%E9%80%BB%E8%BE%91/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://ycjiafei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"二进制加法器","slug":"二进制加法器","date":"2020-12-08T11:18:34.000Z","updated":"2020-12-08T10:30:05.456Z","comments":true,"path":"2020/12/08/二进制加法器/","link":"","permalink":"http://ycjiafei.github.io/2020/12/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%99%A8/","excerpt":"","text":"加法是算术运算中最基本的运算，也是计算机要做的唯一工作。如果我们可以造出加法器，同样地，就可以利用加法来实现减法、乘法和除法，计算按揭付款，引导火箭飞到火星、下棋，以及填写我们的话费账单。 加法表计算二进制数加法与计算十进制数加法非常相似。只需要多次将两个十进制数相加 二进制数加法与十进制数加法最大的不同就在于二进制数加法中用到了一个更为简单的加法表 一对二进制数相加的结果中具有两个数位，其中一位叫做加法位，另一位则叫做进位位 （例如，1加1等于0，进位为1） 所以我们将二进制数加法表分成两个表格，第一个是表示加法的。 用二进制数，问题将在很大程度上得以简化，因为，电路中的所有器件，像开关、灯泡、导线等都可以用来表示二进制数的位 与十进制数加法一样，我们将两个二进制数字串由右向左依次逐列相加 半加器刚才我们知道利用两个逻辑门可以实现加法和进位 两个二进制数相加的结果是由异或门的输出给出的，而进位位是由与门的输出给出的。 因此我们可以将 与门 和 异或门 连在一起来计算两个二进制数（即A和B）的和。 为了避免重复画与门和异或门，可以采用如下这种简单的表示方式 这个符号被称为半加器（Half Adder）。之所以叫半加器是有原因的，它将两个二进制数相加，得出一个加法位和一个进位位。但是绝大多数二进制数是多于1位的。半加器没有做到的是将之前一次的加法可能产生的进位位纳入下一次运算。 全加器为了能对三个二进制数进行加法运算，同时也考虑到进位，我们需要将两个半加器和一个或门做如下连接 工作原理： 首先从最左边第一个半加器的输入A和输入B开始，其输出是一个加和及相应的进位。这个和必须与前一列的进位输入相加，然后再把它们输入到第二个半加器中。第二个半加器的输出和是最后的结果。两个半加器的进位输出又被输入到一个或门中搭建加法器 为了避免重复地画上面的那个图，我们用以下形式来替代上图中的一堆符号，它称为全加器（FullAdder）。 搭建加法器有了上述的知识， 可以试着来搭建一个加法器 简单起见，假设搭建起来的二进制加法器最高能够执行的加法长度为8位。也就是说，我们想要相加的二进制数，其范围是从0000-0000到1111-1111，即十进制数的0到255。两个8位二进制的和最大可为1-1111-1110，即510 在这个面板中，有两排开关，每排8个， 面板底部的输出设备是一排灯泡，共9个(两个8位二进制数的相加结果可能是9位) 其中输入设备是开关：断开（关）即表示0，闭合（开）表示1。 输出设备是灯泡： 不发光的灯泡表示0，发光的灯泡表示1。 连接加法器首先将最右端的两个开关和最右端的一个灯泡连接到一个全加器上。 由于第一列没有进位输入， 所以进位输入直接接地，代表0 对于接下来的两个二进制位和灯泡，可以按如下办法来连接全加器， 往后以此类推 最终，第8个灯泡和最后一对开关将以如下方式连接到全加法器上 最后一个进位输出将被连接到第9个灯泡上 至此，我们就大功告成了。还可以用另一种方式来看这8个全加器的连接，每个全加器的进位输出都作为下一个全加器的进位输入。 简单起见，8位二进制加法器可用下图表示 一旦你搭建起了8位二进制加法器，你就可以再搭建另外一个加法器。把它们级联起来就可以很容易地扩展出一个16位加法器。 “这真的就是计算机进行加法运算时所采用的方式么？ 基本上来说，是的。但也并不完全是。 第一台数字计算机在20世纪30年代被建造完成，当时所使用的就是继电器，后来也使用过真空管。今天的计算机使用的是晶体管。在被用到计算机中时，晶体管的工作方式与继电器基本相同，但是晶体管要比继电器计算速度更快、体积更小，而且噪声更弱、耗能也更低，而且更便宜。搭建一个8位加法器依然需要144个晶体管，但是电路却是极小的。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://ycjiafei.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"逻辑","slug":"逻辑","permalink":"http://ycjiafei.github.io/tags/%E9%80%BB%E8%BE%91/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://ycjiafei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"逻辑与开关","slug":"逻辑与开关","date":"2020-12-07T20:18:34.000Z","updated":"2020-12-08T03:58:00.362Z","comments":true,"path":"2020/12/07/逻辑与开关/","link":"","permalink":"http://ycjiafei.github.io/2020/12/07/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%BC%80%E5%85%B3/","excerpt":"","text":"最著名的三段论法（亚里士多德） 凡人都有死（大前提） 苏格拉底是人（小前提） 所以：苏格拉底有死（结论） 布尔代数布尔代数中，是一种利用数学来描述逻辑的方法。与传统代数非常相似，而且运算规则也非常类似。操作数不是数字而是类（class）。简单说，一个类就是一个事物的群体，它后来也被称为集合（set）。 以猫为例， 用字母 M 代表公猫， 字母 F 代表母猫， 字母 T 代表褐色的猫，字母 B 代表黑猫， 字母 W 代表白猫， O 代表不在 T、B 或 W 集合中其他颜色的猫 ，字母 N 来表示已被绝育的猫， 字母 U 表示未被绝育的猫 由于表示太多， 列一个表格方便后面直观的分析 字母 表示 M 公猫 F 母猫 T 褐色的猫 B 黑猫 W 白猫 O 其他颜色的猫 N 已绝育的猫 U 未绝育的猫 布尔代数符号符号 “+” 或 “U” 或 “OR” 表示两个集合的并集（为了避免在传统代数与布尔代数间混淆， 一般常用后者） 符号 “×” 或 “∩” 或 “AND” 表示两个集合的交集 例如： B + W 表示的是所有黑猫和白猫的集合 ​ F × T 代表的是所有褐色母猫的集合 布尔代数运算传统代数中的交换律、结合律和分配律都在布尔代数中同样成立。 同时布尔代数也有几个特殊的 公式 解释 W + (B× F) = (W + B) × (W + F) 白猫和黑色母猫的并集 = （白猫和黑猫的并集）和（ 白猫和母猫的并集 ） 的交集 M + F = 1 1 表示“全集” 也就是说，公猫与母猫的并集是所有猫 T + B+ W + O = 1 褐色的猫、黑猫、白猫与其他颜色猫的并集也是所有猫的集合 1- M = F 母猫的集合 = 除去公猫的所有猫 F × M = 0 符号0表示空集——不包含任何元素的集合，例如，母猫与公猫的交集 F × ( 1 - F ) = 0 这一条是逻辑学上重要概念，矛盾律：事物不可能既是它本身，同时又是它的对立面 例子: 某天你走进了一家宠物商店，对店员说：“我想要一只公猫，已绝育的，白色或褐色都可以，或者一只母猫，也要是已绝育的，除了白色任何颜色都可以；或者，只要是黑猫就可以。”店员会对你说：“你想要的猫是在以下这样的集合里： ( M × N × ( W + T ) ) + ( F × N × ( 1 - W ) ) + B 对么？”你会说：“是的！正是！” 解析： 有3种猫符合顾客的条件 一只已绝育的白色或褐色公猫 M × N × ( W + T ) 一只已绝育的不是白色的母猫 F × N × ( 1 - W ) 黑猫 B 这3种猫是或关系， 所以用 + 表示得到最终结果 ( M × N × ( W + T ) ) + ( F × N × ( 1 - W ) ) + B 布尔测试继续上面的问题：用 1 或 True 来代表猫符合这样的标准， 用 0 或 False 代表猫不符合标准 首先，店员拿出了一只未绝育的褐色公猫，用 0 和 1替换之后的式子 (1 × 0 × (0 +1)) + (0 × 0×(1-0)) + 0 = 0 结果是 0 不符合我希望猫 接着，店员拿出了一只已绝育的白色母猫。 (0 × 1 ×(1 + 0)) + (1×1×(1-1)) + 0 = 0 因此，第二只小猫也不符合标准。然后，店员拿出了一只已绝育的灰色母猫（灰色属于其他颜色——非白色、黑色或褐色）。表达式如下： (0 × 1 ×(0 + 0)) + (1 × 1× (1- 0) ) + 0 = 1 最后结果为 1，意味着 Yes，True，这个只小猫可以带回家！ 关于布尔表达式的运算规则， 可以参看真值表 毕竟我们希望能将布尔代数和电路相结合， 最终可以构造一个二进制电路的计算机 通过真值表发现 AND 逻辑可以用串联的电路来实现 OR 可以用 并联的电路来实现 于是乎，对于上面的猫猫公式 (M × N × (W+ T)) + (F × N × (1 -W)) + B 我们可以构造如下电路 与之前一样，店员首先拿出了一只未绝育的褐色公猫。闭合相应的开关，如下图所示。 没有成功地点亮灯泡。接着，店员又拿出了一只已绝育的白色母猫 相应的开关闭合后依然没有点亮灯泡。但是，最后店员拿出了一只已绝育的灰色母猫。 这次，灯泡被成功点亮了，表明这只猫符合你的全部要求。 可惜乔治布尔的时代人类还没有发明白炽灯","categories":[{"name":"数学","slug":"数学","permalink":"http://ycjiafei.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"逻辑","slug":"逻辑","permalink":"http://ycjiafei.github.io/tags/%E9%80%BB%E8%BE%91/"},{"name":"数学","slug":"数学","permalink":"http://ycjiafei.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Docker+Vagrant 构建完全自动化的 CI/CD","slug":"Docker-Vagrant-构建完全自动化的-CI-CD","date":"2020-12-03T11:18:34.000Z","updated":"2020-12-07T06:25:47.171Z","comments":true,"path":"2020/12/03/Docker-Vagrant-构建完全自动化的-CI-CD/","link":"","permalink":"http://ycjiafei.github.io/2020/12/03/Docker-Vagrant-%E6%9E%84%E5%BB%BA%E5%AE%8C%E5%85%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84-CI-CD/","excerpt":"","text":"如果你的开发流程是下面👇这个样子的， 那么你一定很好奇， 为什么我提交到仓库的代码可以自动部署并访问到最新的提交内容 这就是近年来兴起的 DevOps 文化， 很方便的解决了开发人员和运维人员每次发布版本需要联调沟通等问题， 缩短了程序发布时间， 可以以更短的周期进行迭代。 所以在收集了很多教程之后， 我也搭建了一个可自动测试，测试用例通过后可自动部署的 CI/CD 流程 实验前准备 VirtualBox 用来模拟需要用到的服务器(大概4台，云服务器也可以) Vagrant 用来编排 VirtualBox 里的虚拟机(一台一台服务器里面配置环境太累了) 了解 Vagrant 和 Docker 的简单用法 初始化服务器环境首先我们要用 VirtualBox 初始化4台centos 系统的Linux主机。 HostName IP Address 作用 gitlab 192.168.33.10 安装gitlab服务，提供代码仓库等作用，类似github gitlab_dns 192.168.33.13 给其他虚拟机提供统一的DNS查找服务， 不用每台虚拟机配置一份hosts文件 gitlab_ci 192.168.33.11 安装 gitlab runner 提供 代码的持续集成服务 gitlab_cd 192.168.33.12 安装 gitlab runner 提供 代码的持续部署服务 按照上面的表格， 我们设定了4台服务器名称， 也给每台服务器固定了内网地址， 这样我们每次重启系统就不用重新配置网络了。结合这份表格可以用 Vargentfile 启动4台服务器并安装好环境（每台系统我单独配置了一份shell脚本， 让环境直接初始化好） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- mode: ruby -*-# vi: set ft&#x3D;ruby :boxes &#x3D; [ &#123; :name &#x3D;&gt; &quot;gitlab&quot;, :eth1 &#x3D;&gt; &quot;192.168.33.10&quot;, :mem &#x3D;&gt; &quot;4096&quot;, :cpu &#x3D;&gt; &quot;2&quot;, :folder &#x3D;&gt; &quot;.&#x2F;gitlab&quot;, :shell &#x3D;&gt; &quot;.&#x2F;gitlab&#x2F;bootstrap.sh&quot; # 这份shell 是安装 gitlab 服务并自启 &#125;, &#123; :name &#x3D;&gt; &quot;gitlab_dns&quot;, :eth1 &#x3D;&gt; &quot;192.168.33.13&quot;, :mem &#x3D;&gt; &quot;1024&quot;, :cpu &#x3D;&gt; &quot;1&quot;, :folder &#x3D;&gt; &quot;.&#x2F;gitlab_dns&quot;, :shell &#x3D;&gt; &quot;.&#x2F;gitlab_dns&#x2F;bootstrap.sh&quot; # 这份shell 是安装 docker 并 通过docker 启动一个dns服务 &#125;, &#123; :name &#x3D;&gt; &quot;gitlab_ci&quot;, :eth1 &#x3D;&gt; &quot;192.168.33.11&quot;, :mem &#x3D;&gt; &quot;2048&quot;, :cpu &#x3D;&gt; &quot;2&quot;, :folder &#x3D;&gt; &quot;.&#x2F;gitlab_ci&quot;, :shell &#x3D;&gt; &quot;.&#x2F;gitlab_ci&#x2F;bootstrap.sh&quot; # 这份shell 是安装 docker 和 gitlab runner 组件 &#125;, &#123; :name &#x3D;&gt; &quot;gitlab_cd&quot;, :eth1 &#x3D;&gt; &quot;192.168.33.12&quot;, :mem &#x3D;&gt; &quot;2048&quot;, :cpu &#x3D;&gt; &quot;2&quot;, :folder &#x3D;&gt; &quot;.&#x2F;gitlab_ci&quot;, :shell &#x3D;&gt; &quot;.&#x2F;gitlab_ci&#x2F;bootstrap.sh&quot; # 这份shell和ci是同一个脚本 &#125;,]Vagrant.configure(&quot;2&quot;) do |config| config.vm.box &#x3D; &quot;centos&#x2F;7&quot; boxes.each do |opts| config.vm.define opts[:name] do |config| config.vm.provider &quot;virtualbox&quot; do |v| v.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, opts[:mem]] v.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, opts[:cpu]] end config.vm.network :private_network, ip: opts[:eth1] config.vm.synced_folder opts[:folder], &quot;&#x2F;mnt&quot;, type: &quot;nfs&quot; config.vm.provision &quot;shell&quot;, path: opts[:shell] end endend 如果顺利初始化成功后， 你将有4台服务器， 分别是 已经安装好 gitlab 的服务器，提供代码的仓库 通过 docker 对外提供dns服务的 gitlab_dns 服务器 安装好 gitlab runner 和 docker 的 ci 服务器 安装好 gitlab runner 和 docker 的 cd 服务器 以上 Vargentfile 和 shell 文件可以到我的 github 仓库上复制 设置 gitlabvagrant up 启动成功上述4台虚拟机后，然后配置一下宿主机的 dns ，用来通过域名方式 http://gitlab.example.com/ 访问 gitlab 页面， 不配置也可以通过直接访问 ip 地址 192.168.33.10 的形式查看 gitlab 第一次启动需要设置密码， 然后可以通过 默认用户名root 和设置的密码登陆 gitlab, 登陆成功后需要像使用 github 一样添加宿主机的公钥到网站上， 放便后面我们对代码的 pull 和 push 添加一个项目能顺利进入 gitlab 了， 那么顺利成章的需要测试一下我们是否能够初始化项目并且成功pull 和 push 操作， 这里有一份 go 代码， 来当作这次ci cd 实验的准备 1234567891011121314151617181920212223242526272829303132# main.gofunc main() &#123; http.HandleFunc(&quot;/&quot;, httpFunc.SayHello) //设置访问的路由 err := http.ListenAndServe(&quot;:9090&quot;, nil) //设置监听的端口 if err != nil &#123; log.Fatal(&quot;ListenAndServe: &quot;, err) &#125;&#125;# httpFunc/helloHandler.gofunc SayHello(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, &quot;Hello World!&quot;) //这个写入到w的是输出到客户端的&#125;# test/main_test.gofunc TestHelloWorld(t *testing.T) &#123; mux := http.NewServeMux() mux.HandleFunc(&quot;/&quot;, httpFunc.SayHello) r, _ := http.NewRequest(http.MethodGet, &quot;/&quot;, nil) w := httptest.NewRecorder() mux.ServeHTTP(w, r) resp := w.Result() if resp.StatusCode != http.StatusOK &#123; t.Errorf(&quot;Response code is %v&quot;, resp.StatusCode) &#125; body, _ := ioutil.ReadAll(resp.Body) defer resp.Body.Close() if string(body) != &quot;Hello World!&quot; &#123; t.Errorf(&quot;Response Body is %s&quot;, string(body)) &#125;&#125; 本地执行单元测试检验下我们的代码是否有问题 12go test .ok code/test 0.109s So, 我们可以在 gitlab 上新建一个仓库 gohttp 来上传了 gitlab runner 设置首先进入我们的 gitlab ci 服务器 vagrant ssh gitlab_ci 配置 dns 1234sudo vim /etc/resolv.confnameserver 192.168.33.13 # 添加这一行然后ping一下域名是否能成功ping gitlab.example.com dns 配置好之后可以设置 gitlab runner 了 进入 gitlab.example.com, 查看 runner 的 token 进入 gitlab_ci 虚拟机 12345678910111213141516[vagrant@localhost ~]$ sudo gitlab-ci-multi-runner registerRuntime platform arch=amd64 os=linux pid=3016 revision=8fa89735 version=13.6.0Running in system-mode.Enter the GitLab instance URL (for example, https://gitlab.com/):http://gitlab.example.com/ # gitlab 域名Enter the registration token:dPLFPqnA1dw2vzkAaENG # gitlab 项目的 tokenEnter a description for the runner:[localhost.localdomain]:Enter tags for the runner (comma-separated):golang-test # runner 的 tagRegistering runner... succeeded runner=dPLFPqnAEnter an executor: kubernetes, shell, ssh, virtualbox, docker+machine, docker-ssh+machine, custom, docker, docker-ssh, parallels:docker # runner 的 环境 Runner registered successfully. Feel free to start it, but if it&#x27;s running already the config should be automatically reloaded! 然后刷新gitlab 页面， 可以看到 runner 已经注册成功了 同样的步骤可以在 gitlab_cd 服务器上执行一遍， 不过这次我们的 runner 环境要选择shell， 至此， 我们有了一个 tag 为 golang-test 的 runner 来执行 我们 go 项目的 ci （自动测试用）， tag 为 docker-deploy 的项目进行 cd （自动部署用） 在项目下新增 dockerfile 用来在docker 中运行我们的项目 123456789FROM golang AS build-envADD . /appWORKDIR /appRUN GOOS=linux GOARCH=386 go build -o gohttp main.goFROM alpineCOPY --from=build-env /app/gohttp /usr/local/bin/gohttpEXPOSE 9090CMD [ &quot;gohttp&quot; ] 新增 .gitlab-ci.yml 让 gitlab runner 运行 12345678910111213141516171819stages: - test - deploytest-job: stage: test tags: - golang-test script: - go test ./testdeploy-job: stage: deploy tags: - docker-deploy script: - docker build -t gohttp . - if [ $(docker ps -aq --filter name=helloworld) ]; then docker rm -f helloworld;fi - docker run -d -p 9090:9090 --name helloworld gohttp 然后将改动 push 到 master 分支， 然后进入 CICD 看板， 可以看到已经在帮我们做ci和cd了 测试通过后会自动部署， 部署成功后可以访问 gitlab_cd 服务器的 ip 和应用程序的端口形式看到部署的应用， 同时也可以在 gitlab dns 服务器上为 cd 服务器添加一个 host 域名， 这样可以直接用域名访问程序 至此， cicd 已经搭建完成， 我在本地经过多次 修改代码 然后 git push 到 gitlab 上， 程序都能相应的执行和部署到 cd服务器的 9090 端口， 大功告成！","categories":[{"name":"docker","slug":"docker","permalink":"http://ycjiafei.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://ycjiafei.github.io/tags/docker/"},{"name":"devops","slug":"devops","permalink":"http://ycjiafei.github.io/tags/devops/"}]},{"title":"About Me","slug":"About-Me","date":"2020-12-03T10:56:33.000Z","updated":"2020-12-03T10:57:18.766Z","comments":true,"path":"2020/12/03/About-Me/","link":"","permalink":"http://ycjiafei.github.io/2020/12/03/About-Me/","excerpt":"","text":"这是第一次创建文章， 关于我","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"1970-01-01T00:00:00.000Z","updated":"2020-12-03T10:34:30.338Z","comments":true,"path":"1970/01/01/hello-world/","link":"","permalink":"http://ycjiafei.github.io/1970/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"项目踩坑","slug":"项目踩坑","permalink":"http://ycjiafei.github.io/categories/%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://ycjiafei.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数学","slug":"数学","permalink":"http://ycjiafei.github.io/categories/%E6%95%B0%E5%AD%A6/"},{"name":"docker","slug":"docker","permalink":"http://ycjiafei.github.io/categories/docker/"}],"tags":[{"name":"项目踩坑","slug":"项目踩坑","permalink":"http://ycjiafei.github.io/tags/%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91/"},{"name":"Redis","slug":"Redis","permalink":"http://ycjiafei.github.io/tags/Redis/"},{"name":"逻辑","slug":"逻辑","permalink":"http://ycjiafei.github.io/tags/%E9%80%BB%E8%BE%91/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://ycjiafei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数学","slug":"数学","permalink":"http://ycjiafei.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"docker","slug":"docker","permalink":"http://ycjiafei.github.io/tags/docker/"},{"name":"devops","slug":"devops","permalink":"http://ycjiafei.github.io/tags/devops/"}]}